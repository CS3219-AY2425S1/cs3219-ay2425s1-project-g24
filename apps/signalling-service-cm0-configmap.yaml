apiVersion: v1
data:
  .env: |-
    PORT=4444
    JWT_SECRET=63059c735adba274cde40f2b1c0b955842d531b115bb4df3058d769b173dcc78
  .env.example: |-
    PORT=4444
    JWT_SECRET=you-can-replace-this-with-your-own-secret
  .gitignore: |-
    node_modules
    .env
  Dockerfile: |-
    FROM node:18-alpine AS base

    # Install dependencies only when needed
    FROM base AS deps
    # Check https://github.com/nodejs/docker-node/tree/b4117f9333da4138b03a546ec926ef50a31506c3#nodealpine to understand why libc6-compat might be needed.
    RUN apk add --no-cache libc6-compat
    WORKDIR /app

    COPY package*.json pnpm-lock.yaml* ./
    RUN \
        if [ -f pnpm-lock.yaml ]; then corepack enable pnpm && pnpm i --frozen-lockfile; \
        else echo "Lockfile not found." && exit 1; \
        fi

    COPY . .

    # Expose port 3001 so it can be mapped by Docker daemon.
    EXPOSE 4444

    # Define the command to run your app using CMD which defines your runtime.
    CMD [ "node", "server.js" ]
  README.md: |
    This is a signalling server that is used to establish WebRTC connections between users. It is built using Node.js and Socket.IO.

    ## Getting Started

    First, install the dependencies:

    ```bash
    npm install -g pnpm

    pnpm install --frozen-lockfile

    # if pnpm install --frozen-lockfile fails, try running
    pnpm install
    ```

    Then, follow the `.env.example` file and create a `.env` file in the current directory. Replace the necessary values within.

    ```bash
    PORT=4444
    ```

    First, run the development server:

    ```bash
    pnpm dev
    ```

    ## Build Dockerfile

    ```bash
    docker build -t signalling-service -f Dockerfile .
    ```

    ## Run Docker Container

    ```bash
    docker run -p 4444:4444 --env-file .env -d signalling-service
    ```
  package.json: |
    {
      "name": "signalling-service",
      "version": "1.0.0",
      "description": "",
      "main": "server.js",
      "scripts": {
        "test": "echo \"Error: no test specified\" && exit 1",
        "dev": "node server.js"
      },
      "type": "module",
      "keywords": [],
      "author": "",
      "license": "ISC",
      "dependencies": {
        "lib0": "^0.2.98",
        "ws": "^8.18.0"
      }
    }
  pnpm-lock.yaml: |
    lockfileVersion: '6.0'

    settings:
      autoInstallPeers: true
      excludeLinksFromLockfile: false

    dependencies:
      lib0:
        specifier: ^0.2.98
        version: 0.2.98
      ws:
        specifier: ^8.18.0
        version: 8.18.0

    packages:

      /isomorphic.js@0.2.5:
        resolution: {integrity: sha512-PIeMbHqMt4DnUP3MA/Flc0HElYjMXArsw1qwJZcm9sqR8mq3l8NYizFMty0pWwE/tzIGH3EKK5+jes5mAr85yw==}
        dev: false

      /lib0@0.2.98:
        resolution: {integrity: sha512-XteTiNO0qEXqqweWx+b21p/fBnNHUA1NwAtJNJek1oPrewEZs2uiT4gWivHKr9GqCjDPAhchz0UQO8NwU3bBNA==}
        engines: {node: '>=16'}
        hasBin: true
        dependencies:
          isomorphic.js: 0.2.5
        dev: false

      /ws@8.18.0:
        resolution: {integrity: sha512-8VbfWfHLbbwu3+N6OKsOMpBdT4kXPDDB9cJk2bJ6mh9ucxdlnNvH1e+roYkKmN9Nxw2yjz7VzeO9oOz2zJ04Pw==}
        engines: {node: '>=10.0.0'}
        peerDependencies:
          bufferutil: ^4.0.1
          utf-8-validate: '>=5.0.2'
        peerDependenciesMeta:
          bufferutil:
            optional: true
          utf-8-validate:
            optional: true
        dev: false
  server.js: |
    // Referenced from https://github.com/yjs/y-webrtc/blob/master/bin/server.js

    import { WebSocketServer } from "ws";
    import http from "http";
    import * as map from "lib0/map";

    const wsReadyStateConnecting = 0;
    const wsReadyStateOpen = 1;
    const wsReadyStateClosing = 2;
    const wsReadyStateClosed = 3;

    const pingTimeout = 30000;

    const port = process.env.PORT || 4444;
    const wss = new WebSocketServer({ noServer: true });

    // Initialise the signalling server for collaboration editor
    const server = http.createServer((request, response) => {
      response.writeHead(200, {
        "Content-Type": "text/plain",
        "Access-Control-Allow-Origin": "*", // Allow all origins for testing
      });
      response.end("okay");
    });

    const topics = new Map();

    const send = (conn, message) => {
      if (
        conn.readyState !== wsReadyStateConnecting &&
        conn.readyState !== wsReadyStateOpen
      ) {
        conn.close();
      }
      try {
        conn.send(JSON.stringify(message));
      } catch (e) {
        conn.close();
      }
    };

    const onconnection = (conn) => {
      const subscribedTopics = new Set();
      let closed = false;
      let pongReceived = true;
      const pingInterval = setInterval(() => {
        if (!pongReceived) {
          conn.close();
          clearInterval(pingInterval);
        } else {
          pongReceived = false;
          try {
            conn.ping();
          } catch (e) {
            conn.close();
          }
        }
      }, pingTimeout);
      conn.on("pong", () => {
        pongReceived = true;
      });
      conn.on("close", () => {
        subscribedTopics.forEach((topicName) => {
          const subs = topics.get(topicName) || new Set();
          subs.delete(conn);
          if (subs.size === 0) {
            topics.delete(topicName);
          }
        });
        subscribedTopics.clear();
        closed = true;
      });
      conn.on("message", (message) => {
        if (typeof message === "string" || message instanceof Buffer) {
          message = JSON.parse(message.toString());
        }
        if (message && message.type && !closed) {
          switch (message.type) {
            case "subscribe":
              (message.topics || []).forEach((topicName) => {
                if (typeof topicName === "string") {
                  const topic = map.setIfUndefined(
                    topics,
                    topicName,
                    () => new Set()
                  );
                  topic.add(conn);
                  subscribedTopics.add(topicName);
                }
              });
              break;
            case "unsubscribe":
              (message.topics || []).forEach((topicName) => {
                const subs = topics.get(topicName);
                if (subs) {
                  subs.delete(conn);
                }
              });
              break;
            case "publish":
              if (message.topic) {
                const receivers = topics.get(message.topic);
                if (receivers) {
                  message.clients = receivers.size;
                  receivers.forEach((receiver) => send(receiver, message));
                }
              }
              break;
            case "ping":
              send(conn, { type: "pong" });
              break;
          }
        }
      });
    };

    wss.on("connection", onconnection);

    server.on("upgrade", (request, socket, head) => {
      const handleAuth = (ws) => {
        wss.emit("connection", ws, request);
      };
      wss.handleUpgrade(request, socket, head, handleAuth);
    });

    server.listen(port);

    console.log("Signaling server running on localhost:", port);
kind: ConfigMap
metadata:
  labels:
    io.kompose.service: signalling-service
  name: signalling-service-cm0
