apiVersion: v1
data:
  .dockerignore: |
    .env.example

    .git
    .gitignore

    .dockerignore
    Dockerfile

    README.md
  .env: "PORT=8081\nMATCH_TIMEOUT=30\nJWT_SECRET=63059c735adba274cde40f2b1c0b955842d531b115bb4df3058d769b173dcc78 \nREDIS_URL=redis-container:6379\nQUESTION_SERVICE_GRPC_URL=question-service:50051\n\n\n# If you are NOT USING docker, use the below variables\n# REDIS_URL=localhost:6379\n# QUESTION_SERVICE_GRPC_URL=localhost:50051\n\n# If you are USING docker, use the below variables\n# REDIS_URL=redis-container:6379\n# QUESTION_SERVICE_GRPC_URL=question-service:50051 # MIGHT HAVE TO CHANGE THIS LATER\n\n\n# SEAN TIN VARIABLES\n# REDIS_URL=10.131.54.91:6379\n# REDIS_URL=localhost:6379\n# REDIS_URL=redis-container:6379"
  .env.example: |
    PORT=8081
    MATCH_TIMEOUT=30
    JWT_SECRET=you-can-replace-this-with-your-own-secret

    # If you are NOT USING docker, use the below variables
    REDIS_URL=localhost:6379
    QUESTION_SERVICE_GRPC_URL=localhost:50051

    # If you are USING docker, use the below variables
    # REDIS_URL=redis-container:6379
    # QUESTION_SERVICE_GRPC_URL=question-service:50051
  .gitignore: .env
  Dockerfile: |
    FROM golang:1.23

    WORKDIR /usr/src/app

    # pre-copy/cache go.mod for pre-downloading dependencies and only redownloading them in subsequent builds if they change
    COPY go.mod go.sum ./

    RUN go mod tidy && go mod download && go mod verify

    COPY .env /usr/src/app/.env

    COPY . .

    RUN go build -v -o /usr/local/bin/app ./main.go

    EXPOSE 8081

    CMD ["app"]
  README.md: |
    # Matching Service

    The Matching Service provides a WebSocket server to manage real-time matching requests through WebSocket connections. It is implemented in Go and uses the Gorilla WebSocket package to facilitate communication.

    ## Setup

    ### Prerequisites

    Ensure you have Go installed on your machine.

    ### Installation

    1. Navigate to the matching service directory:

    ```bash
    cd ./apps/matching-service
    ```

    2. Install the necessary dependencies:

    ```bash
    go mod tidy
    ```

    3. Create a copy of the `.env.example` file as an `.env` file with the following environment variables:

    - `PORT`: Specifies the port for the WebSocket server. Default is `8081`.
    - `JWT_SECRET`: The secret key used to verify JWT tokens.
    - `MATCH_TIMEOUT`: The time in seconds to wait for a match before timing out.
    - `REDIS_URL`: The URL for the Redis server. Default is `localhost:6379`. If you are using docker, use `redis-container:6379`

    4. Start a local Redis server:

    ```bash
    docker run -d -p 6379:6379 redis
    ```

    5. Start the WebSocket server:

    ```bash
    go run main.go
    ```

    ## API Usage

    To establish a WebSocket connection with the matching service, use the following JavaScript code:

    ```javascript
    const ws = new WebSocket("ws://localhost:8081/match");
    ```

    ### Authentication

    The initial WebSocket request should include a JWT token that contains the userâ€™s ID as a claim. This token will be verified by the server to authenticate the user. The user ID extracted is used to identify the client and facilitate the matching process.

    ### Matching Workflow

    1. **Sending Matching Parameter**s: Once the WebSocket connection is established, the client sends a message containing the matching parameters (e.g., preferred topics or difficulty levels).

    2. **Receiving Match Results**:
       2.1. **Match Found**: If a match is found, the server sends the matching result back to the client via the WebSocket connection.
       2.2. **No Match Found**: If after a set amount of time, no match is found, the request timeouts, and the server sends a message that the matching failed.

    3. **Connection Closure**:
       3.1. **Received Match Result**: After sending the match result, the server closes the connection.
       3.2. **Cancellation**: If the user cancels the matching process, the client should close the connection. The server will recognize this and cancel the ongoing match.

    ### Message Formats

    Provide the structure of the messages being sent back and forth between the server and the client. This includes the format of the initial matching parameters and the response payload. All requests should be in JSON and contain the `type` field to handle different types of messages.

    Client sends matching parameters:

    ```json
    {
      "type": "match_request",
      "topics": ["Algorithms", "Arrays"],
      "difficulties": ["easy", "medium"],
      "username": "1f0myn"
    }
    ```

    Server response on successful match:

    ```json
    {
      "type": "match_question_found",
      "match_id": "c377f463d380a9bd1dd03242892ef32e",
      "user": "1f0myn",
      "matched_user": "jrsznp",
      "matched_topics": ["Graphs", "Bit Manipulation", "Databases"],
      "question_doc_ref_id": "5lObMfyyKPgNXSuLcGEm",
      "question_name": "Repeated DNA Sequences",
      "question_difficulty": "medium",
      "question_topics": ["Algorithms", "Bit Manipulation"]
    }
    ```

    If no match is found after a set period of time, the server will send a timeout message:

    ```json
    {
      "type": "timeout",
      "message": "No match found. Please try again later."
    }
    ```

    If user has an existing websocket connection and wants to initiate another match, the server will reject the request:

    ```json
    {
      "type": "match_rejected",
      "message": "You are already in a matchmaking queue. Please disconnect before reconnecting."
    }
    ```

    If the server encounters an issue during the WebSocket connection or processing, the connection will be closed without any error message. The client should treat the unexpected closing as an error.

    ## Testing

    Utilize `./tests/websocket-test.html` for a basic debugging interface of the matching service. This HTML file provides an interactive way to test the WebSocket connection, send matching requests, and observe responses from the server.

    Make sure to open the HTML file in a web browser while the WebSocket server is running to perform your tests.

    You can open one instance of the HTML file in multiple tabs to simulate multiple clients connecting to the server. (In the future: ensure that only one connection is allowed per user)

    ## Running the Application via Docker

    Before running the following commands, ensure that the URL for the Redis server in `.env` file has been changed to `REDIS_URL=redis-container:6379`

    To run the application via Docker, run the following command:

    1. Set up the Go Docker container for the matching service

    ```bash
    docker build -f Dockerfile -t match-go-app .
    ```

    2. Create the Docker network for Redis and Go

    ```bash
    docker network create redis-go-network
    ```

    3. Start a new Redis container in detached mode using the Redis image from Docker Hub

    ```bash
    docker run -d --name redis-container --network redis-go-network redis
    ```

    4. Run the Go Docker container for the matching-service

    ```bash
    docker run -d -p 8081:8081 --name go-app-container --network redis-go-network match-go-app
    ```

    **NOTE:** As there is a dependency on the question-service to return the found questions, the matching-service does not work fully unless the question-service is present.
  go.mod: |
    module matching-service

    go 1.23.1

    require (
    	github.com/bsm/redislock v0.9.4
    	github.com/gorilla/websocket v1.5.3
    	github.com/joho/godotenv v1.5.1
    	github.com/redis/go-redis/v9 v9.6.2
    	google.golang.org/grpc v1.67.1
    	google.golang.org/protobuf v1.35.1
    )

    require (
    	github.com/cespare/xxhash/v2 v2.3.0 // indirect
    	github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f // indirect
    	golang.org/x/net v0.28.0 // indirect
    	golang.org/x/sys v0.24.0 // indirect
    	golang.org/x/text v0.17.0 // indirect
    	google.golang.org/genproto/googleapis/rpc v0.0.0-20240814211410-ddb44dafa142 // indirect
    )
  go.sum: |
    github.com/bsm/ginkgo/v2 v2.12.0 h1:Ny8MWAHyOepLGlLKYmXG4IEkioBysk6GpaRTLC8zwWs=
    github.com/bsm/ginkgo/v2 v2.12.0/go.mod h1:SwYbGRRDovPVboqFv0tPTcG1sN61LM1Z4ARdbAV9g4c=
    github.com/bsm/gomega v1.27.10 h1:yeMWxP2pV2fG3FgAODIY8EiRE3dy0aeFYt4l7wh6yKA=
    github.com/bsm/gomega v1.27.10/go.mod h1:JyEr/xRbxbtgWNi8tIEVPUYZ5Dzef52k01W3YH0H+O0=
    github.com/bsm/redislock v0.9.4 h1:X/Wse1DPpiQgHbVYRE9zv6m070UcKoOGekgvpNhiSvw=
    github.com/bsm/redislock v0.9.4/go.mod h1:Epf7AJLiSFwLCiZcfi6pWFO/8eAYrYpQXFxEDPoDeAk=
    github.com/cespare/xxhash/v2 v2.3.0 h1:UL815xU9SqsFlibzuggzjXhog7bL6oX9BbNZnL2UFvs=
    github.com/cespare/xxhash/v2 v2.3.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=
    github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f h1:lO4WD4F/rVNCu3HqELle0jiPLLBs70cWOduZpkS1E78=
    github.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f/go.mod h1:cuUVRXasLTGF7a8hSLbxyZXjz+1KgoB3wDUb6vlszIc=
    github.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=
    github.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
    github.com/gorilla/websocket v1.5.3 h1:saDtZ6Pbx/0u+bgYQ3q96pZgCzfhKXGPqt7kZ72aNNg=
    github.com/gorilla/websocket v1.5.3/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=
    github.com/joho/godotenv v1.5.1 h1:7eLL/+HRGLY0ldzfGMeQkb7vMd0as4CfYvUVzLqw0N0=
    github.com/joho/godotenv v1.5.1/go.mod h1:f4LDr5Voq0i2e/R5DDNOoa2zzDfwtkZa6DnEwAbqwq4=
    github.com/redis/go-redis/v9 v9.6.2 h1:w0uvkRbc9KpgD98zcvo5IrVUsn0lXpRMuhNgiHDJzdk=
    github.com/redis/go-redis/v9 v9.6.2/go.mod h1:0C0c6ycQsdpVNQpxb1njEQIqkx5UcsM8FJCQLgE9+RA=
    golang.org/x/net v0.28.0 h1:a9JDOJc5GMUJ0+UDqmLT86WiEy7iWyIhz8gz8E4e5hE=
    golang.org/x/net v0.28.0/go.mod h1:yqtgsTWOOnlGLG9GFRrK3++bGOUEkNBoHZc8MEDWPNg=
    golang.org/x/sys v0.24.0 h1:Twjiwq9dn6R1fQcyiK+wQyHWfaz/BJB+YIpzU/Cv3Xg=
    golang.org/x/sys v0.24.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
    golang.org/x/text v0.17.0 h1:XtiM5bkSOt+ewxlOE/aE/AKEHibwj/6gvWMl9Rsh0Qc=
    golang.org/x/text v0.17.0/go.mod h1:BuEKDfySbSR4drPmRPG/7iBdf8hvFMuRexcpahXilzY=
    google.golang.org/genproto/googleapis/rpc v0.0.0-20240814211410-ddb44dafa142 h1:e7S5W7MGGLaSu8j3YjdezkZ+m1/Nm0uRVRMEMGk26Xs=
    google.golang.org/genproto/googleapis/rpc v0.0.0-20240814211410-ddb44dafa142/go.mod h1:UqMtugtsSgubUsoxbuAoiCXvqvErP7Gf0so0mK9tHxU=
    google.golang.org/grpc v1.67.1 h1:zWnc1Vrcno+lHZCOofnIMvycFcc0QRGIzm9dhnDX68E=
    google.golang.org/grpc v1.67.1/go.mod h1:1gLDyUQU7CTLJI90u3nXZ9ekeghjeM7pTDZlqFNg2AA=
    google.golang.org/protobuf v1.35.1 h1:m3LfL6/Ca+fqnjnlqQXNpFPABW1UD7mjh8KO2mKFytA=
    google.golang.org/protobuf v1.35.1/go.mod h1:9fA7Ob0pmnwhb644+1+CVWFRbNajQ6iRojtC/QF5bRE=
  main.go: |
    package main

    import (
    	"fmt"
    	"log"
    	"matching-service/handlers"
    	"matching-service/servers"
    	"net/http"
    	"os"

    	"github.com/joho/godotenv"
    )

    func main() {
    	setUpEnvironment()
    	client := servers.SetupRedisClient()
    	defer client.Close()
    	grpcClient := servers.InitGrpcServer()
    	defer grpcClient.Close()
    	setupRoutes()
    	startServer()
    }

    func setUpEnvironment() {
    	err := godotenv.Load()
    	if err != nil {
    		log.Fatalf("err loading: %v", err)
    	}
    }

    func setupRoutes() {
    	http.HandleFunc("/match", handlers.HandleWebSocketConnections)
    }

    func startServer() {
    	port := os.Getenv("PORT")
    	log.Println(fmt.Sprintf("Server starting on :%s", port))
    	err := http.ListenAndServe(fmt.Sprintf(":%s", port), nil)
    	if err != nil {
    		log.Fatal("ListenAndServe: ", err)
    	}
    }
kind: ConfigMap
metadata:
  labels:
    io.kompose.service: matching-service
  name: matching-service-cm0
